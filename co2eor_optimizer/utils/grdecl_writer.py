import numpy as np
import logging
from pathlib import Path
from typing import Optional # Added for type hinting

# Assuming core.py is two levels up (e.g., project_root/package_name/core.py)
# and this file is project_root/package_name/utils/grdecl_writer.py
from ..core import ReservoirData

logger = logging.getLogger(__name__)

def _format_array_for_grdecl(arr: np.ndarray, items_per_line: int = 8, is_int_property: bool = False) -> str:
    """
    Formats a NumPy array into a string suitable for GRDECL output.

    Args:
        arr: NumPy array to format.
        items_per_line: Maximum number of values per line in the output string.
        is_int_property: If True, values are formatted as integers. Otherwise, as floats.

    Returns:
        A string with formatted values, newline-separated.
    """
    if not isinstance(arr, np.ndarray):
        logger.error(f"Input to _format_array_for_grdecl must be a numpy array, got {type(arr)}")
        return ""
    if arr.size == 0:
        return ""

    lines = []
    temp_list = []
    
    for i_val, val in enumerate(arr.flatten()): # Ensure array is flat
        if np.isnan(val): # Handle NaNs explicitly, common in reservoir data
            formatted_val = "NAN" # Or some other GRDECL compatible NaN representation if available
        elif is_int_property:
            try:
                formatted_val = str(int(round(val))) # Round before int conversion for safety
            except ValueError:
                logger.warning(f"Could not convert {val} to int, using 0.")
                formatted_val = "0"
        else:
            # Smart float formatting
            if abs(val) > 1e-5 and abs(val) < 1e7 and val == round(val): # Reasonably sized integer-like float
                 formatted_val = str(int(round(val)))
            else:
                 formatted_val = f"{val:.7G}" # General format with good precision

        temp_list.append(formatted_val)
        
        if (i_val + 1) % items_per_line == 0 or i_val == len(arr) - 1:
            lines.append("  " + " ".join(temp_list)) # Indent data lines
            temp_list = []
            
    return "\n".join(lines)

def write_grdecl(reservoir_data: ReservoirData, output_filepath: Union[str, Path]) -> None:
    """
    Writes reservoir grid data to a GRDECL file.

    Args:
        reservoir_data: ReservoirData object containing grid information.
        output_filepath: Path to save the GRDECL file.
    """
    output_filepath = Path(output_filepath)
    if not reservoir_data.grid:
        logger.error("ReservoirData contains no grid data to write.")
        raise ValueError("No grid data available in ReservoirData object.")

    grid_data = reservoir_data.grid
    content_lines = ["-- GRDECL file generated by CO2 EOR Optimizer application", ""]

    # Grid dimensions
    nx, ny, nz = (0,0,0)
    if 'DIMENS' in grid_data and isinstance(grid_data['DIMENS'], (tuple, list, np.ndarray)) and len(grid_data['DIMENS']) == 3:
        nx, ny, nz = map(int, grid_data['DIMENS'])
        content_lines.append("DIMENS")
        content_lines.append(f"  {nx} {ny} {nz} /")
        content_lines.append("")
    elif 'SPECGRID_DIMS' in grid_data and isinstance(grid_data['SPECGRID_DIMS'], (tuple, list, np.ndarray)) and len(grid_data['SPECGRID_DIMS']) == 3:
        nx, ny, nz = map(int, grid_data['SPECGRID_DIMS'])
        lgr_name = grid_data.get('SPECGRID_LGR', 'ROOT') 
        pillar_flag = grid_data.get('SPECGRID_PILLAR_FLAG', 1) # Default for pillar grids
        content_lines.append("SPECGRID")
        content_lines.append(f"  {nx} {ny} {nz} {lgr_name} {pillar_flag} /")
        content_lines.append("")
    else:
        logger.error("Grid dimensions (DIMENS or SPECGRID_DIMS as a 3-element tuple/list) not found in ReservoirData.")
        raise ValueError("Grid dimensions not found or invalid in ReservoirData.")

    grdecl_geometry_keywords = ['COORD', 'ZCORN', 'ACTNUM']
    
    excluded_keys = ['DIMENS', 'SPECGRID_DIMS', 'SPECGRID_LGR', 'SPECGRID_PILLAR_FLAG'] + grdecl_geometry_keywords
    property_keywords = sorted([
        k for k, v in grid_data.items() 
        if k.upper() not in map(str.upper, excluded_keys) and isinstance(v, np.ndarray)
    ])
    
    all_keywords_to_write = grdecl_geometry_keywords + property_keywords

    for keyword in all_keywords_to_write:
        if keyword in grid_data:
            data_array = grid_data[keyword]
            if isinstance(data_array, np.ndarray):
                content_lines.append(keyword.upper()) # Standard GRDECL keywords are upper case
                
                is_int_data = (keyword.upper() == 'ACTNUM') # Add other known integer properties if any
                
                items_per_line = 10
                if keyword.upper() == 'COORD': items_per_line = 6 # Typically 6 values (X,Y,Z for 2 points) per line or just many
                elif keyword.upper() == 'ZCORN': items_per_line = 8 # Typically 8 values per line or many
                elif is_int_data: items_per_line = 20
                
                formatted_data = _format_array_for_grdecl(data_array, items_per_line=items_per_line, is_int_property=is_int_data)
                if formatted_data: # Only append if there's data
                    content_lines.append(formatted_data)
                content_lines.append("/")
                content_lines.append("") 
            else:
                logger.warning(f"Skipping keyword {keyword} as its data is not a NumPy array (type: {type(data_array)}).")
    
    try:
        output_filepath.parent.mkdir(parents=True, exist_ok=True) # Ensure directory exists
        with open(output_filepath, 'w') as f:
            f.write("\n".join(content_lines))
        logger.info(f"Successfully wrote GRDECL file to {output_filepath}")
    except IOError as e:
        logger.error(f"Failed to write GRDECL file {output_filepath}: {e}")
        raise
    except Exception as e:
        logger.error(f"An unexpected error occurred while writing GRDECL file {output_filepath}: {e}")
        raise
